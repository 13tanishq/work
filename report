package com.yourorg.common.validation;

import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;
import org.yaml.snakeyaml.Yaml;

import java.lang.reflect.Field;
import java.util.*;
import java.util.regex.Pattern;

@Component
public class DynamicValidationService implements org.springframework.beans.factory.InitializingBean {

    private final Map<String, Map<String, List<FieldRule>>> rulesByDto = new HashMap<>();

    @Override
    public void afterPropertiesSet() throws Exception {
        Yaml yaml = new Yaml();
        try (var in = new ClassPathResource("field-validations.yml").getInputStream()) {
            Object loadedObj = yaml.load(in);
            if (!(loadedObj instanceof Map<?, ?> loadedMap)) {
                throw new IllegalStateException("Top level YAML should be a map of DTO class names.");
            }
            for (var dtoEntry : loadedMap.entrySet()) {
                String dtoName = String.valueOf(dtoEntry.getKey());
                Object fieldsObj = dtoEntry.getValue();
                if (!(fieldsObj instanceof Map<?, ?> fieldsMap)) continue;

                Map<String, List<FieldRule>> fieldRulesByName = new HashMap<>();
                for (var fieldEntry : fieldsMap.entrySet()) {
                    String fieldName = String.valueOf(fieldEntry.getKey());
                    Object rulesObj = fieldEntry.getValue();

                    // Always treat rules as a List of rule-maps
                    List<Map<String, Object>> ruleList = new ArrayList<>();
                    if (rulesObj instanceof List<?> l) {
                        for (Object ruleItem : l) {
                            if (ruleItem instanceof Map<?, ?> r) {
                                // Convert to Map<String,Object>
                                Map<String, Object> castedRule = new HashMap<>();
                                r.forEach((k, v) -> castedRule.put(String.valueOf(k), v));
                                ruleList.add(castedRule);
                            }
                        }
                    } else if (rulesObj instanceof Map<?, ?> r) {
                        Map<String, Object> castedRule = new HashMap<>();
                        r.forEach((k, v) -> castedRule.put(String.valueOf(k), v));
                        ruleList.add(castedRule);
                    } // else: skip invalid rule entry

                    List<FieldRule> fieldRules = new ArrayList<>();
                    for (Map<String, Object> ruleMap : ruleList) {
                        fieldRules.add(FieldRule.from(ruleMap));
                    }
                    fieldRulesByName.put(fieldName, fieldRules);
                }
                rulesByDto.put(dtoName, fieldRulesByName);
            }
        }
    }

    public List<Violation> validate(Object dto) {
        List<Violation> result = new ArrayList<>();
        if (dto == null) {
            result.add(new Violation("body", "Request body is missing or not valid JSON"));
            return result;
        }
        String dtoSimpleName = dto.getClass().getSimpleName();
        Map<String, List<FieldRule>> fieldRules = rulesByDto.get(dtoSimpleName);
        if (fieldRules == null) return result;
        for (var fieldEntry : fieldRules.entrySet()) {
            try {
                String field = fieldEntry.getKey();
                Field reflectField = dto.getClass().getDeclaredField(field);
                reflectField.setAccessible(true);
                Object valueObj = reflectField.get(dto);
                String value = (valueObj == null) ? null : valueObj.toString();
                for (FieldRule rule : fieldEntry.getValue()) {
                    if (!rule.isValid(value)) {
                        result.add(new Violation(field, rule.message));
                    }
                }
            } catch (Exception e) {
                // Optionally add a Violation or log
            }
        }
        return result;
    }

    static class FieldRule {
        String type;
        String message;
        String pattern;
        Integer min, max;

        static FieldRule from(Map<String,Object> map) {
            FieldRule r = new FieldRule();
            r.type = (String) map.get("type");
            r.message = (String) map.get("message");
            r.pattern = (String) map.get("pattern");
            if (map.get("min") instanceof Integer mi) r.min = mi;
            if (map.get("max") instanceof Integer ma) r.max = ma;
            return r;
        }

        boolean isValid(String value) {
            if ("required".equals(type)) return value != null && !value.isBlank();
            if ("regex".equals(type)) return (value != null) && Pattern.matches(pattern, value);
            if ("length".equals(type)) {
                if (value == null) return false;
                int len = value.length();
                if (min != null && len < min) return false;
                if (max != null && len > max) return false;
            }
            return true;
        }
    }

    public static class Violation {
        public String field, message;
        public Violation(String f, String m) { field = f; message = m; }
    }
}



SampleDto: 
  fromAddress:
    - type: regex
      pattern: '^.+@.+\..+$'
      message: 'fromAddress must be a valid email'
  someOtherField:
    - type: required
      message: 'Field is required'
