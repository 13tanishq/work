import com.fasterxml.jackson.databind.ObjectMapper; // <-- Import ObjectMapper
import org.springframework.beans.factory.annotation.Autowired; // For DI
// ... other imports

@RestController
@RequestMapping("/api/v1/requests")
public class ConsumerController {

    @Autowired
    private ValidationService validationService; // Assuming you inject your service

    @Autowired
    private ObjectMapper objectMapper; // Inject the ObjectMapper

    // ... your existing ApiOperation, etc. annotations
    @PostMapping
    @ApiOperation(value = "...", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    // ... all your @ApiResponse annotations
    public ResponseEntity<?> processDocument(
            @RequestParam(value = "type") String type,
            @RequestBody Map<String, Object> requestPayload) { // <-- Accept a generic Map

        // This object will hold our specific request type (Email, Invoice, etc.)
        Object specificRequest;

        // Use the 'type' parameter to determine the target class
        try {
            switch (type.toUpperCase()) {
                case "EMAIL":
                    specificRequest = objectMapper.convertValue(requestPayload, EmailRequest.class);
                    break;
                case "INVOICE":
                    specificRequest = objectMapper.convertValue(requestPayload, InvoiceRequest.class);
                    break;
                case "FTP":
                    specificRequest = objectMapper.convertValue(requestPayload, FtpRequest.class);
                    break;
                // Add other cases for MAILING, FAX, etc.
                // case "MAILING":
                //     specificRequest = objectMapper.convertValue(requestPayload, MailingRequest.class);
                //     break;
                default:
                    // Handle unknown type
                    throw new UnsupportedOperationException("Request type '" + type + "' is not supported.");
            }

            // Now, validate the strongly-typed object
            // Your validation service should be able to handle a generic Object
            // and use the annotations on the passed instance (EmailRequest, InvoiceRequest, etc.)
            validationService.validateOrfail(specificRequest);

            // ... your existing logic continues here ...
            // You might need to cast 'specificRequest' back to its type if you need
            // to access specific fields later in this method.

            // Example:
            // if (specificRequest instanceof EmailRequest) {
            //     EmailRequest emailRequest = (EmailRequest) specificRequest;
            //     // do something with emailRequest
            // }

            // ... your try/catch for the business logic ...
            return ResponseEntity.ok("Successfully processed " + type + " request.");


        } catch (IllegalArgumentException e) {
            // This catches errors from objectMapper.convertValue if fields don't match
            // and also the UnsupportedOperationException we threw.
            return ResponseEntity.badRequest().body("Invalid request payload for type '" + type + "'. " + e.getMessage());
        }
        // Your existing exception handling for validation errors should catch the
        // exception thrown by validationService.validateOrfail()
    }
}
