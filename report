package com.socgen.sirocco.consumerapi.exceptions.handler;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonStreamContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.io.IOException;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    @Autowired
    private MessageSource messageSource;

    // Handler 1: JSON syntax errors (malformed JSON)
    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            HttpHeaders headers,
            HttpStatus status,
            WebRequest request) {

        Throwable cause = ex.getCause();
        String field = "body";
        String message = "Malformed JSON";

        if (cause instanceof JsonParseException jpe) {
            field = findFieldNameFromContext(jpe);
            message = messageSource.getMessage(
                    getSyntaxErrorKey(jpe.getOriginalMessage()),
                    null,
                    Locale.getDefault());
        }

        return ResponseEntity.badRequest()
                .body(List.of(new Violation(field, message)));
    }

    // Handler 2: Data validation errors (all bean validation failures)
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatus status,
            WebRequest request) {

        List<Violation> violations = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> new Violation(
                        error.getField(),
                        error.getDefaultMessage()))
                .collect(Collectors.toList());

        return ResponseEntity.badRequest().body(violations);
    }

    // Handler 3: Catch-all for any other unexpected exception (e.g., NullPointerException)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleAllOthers(Exception ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(List.of(new Violation("error", "An unexpected error occurred.")));
    }

    // Helper: map Jackson syntax errors to keys for i18n-friendly messages
    private String getSyntaxErrorKey(String originalMessage) {
        if (originalMessage.contains("was expecting comma"))
            return "json.syntax.error.missing.comma";
        if (originalMessage.contains("Unexpected end-of-input") && originalMessage.contains("Array"))
            return "json.syntax.error.unclosed.array";
        if (originalMessage.contains("Unexpected end-of-input") && originalMessage.contains("Object"))
            return "json.syntax.error.unclosed.object";
        return "json.syntax.error.generic";
    }

    // Helper: find problematic field in JSON parsing context
    private String findFieldNameFromContext(JsonParseException jpe) {
        try {
            JsonStreamContext ctx = jpe.getProcessor().getParsingContext();
            if (ctx != null && ctx.getCurrentName() != null) {
                return ctx.getCurrentName();
            }
        } catch (IOException ignored) {}
        return "body";
    }

    // Simple DTO record for every error in the response array
    public record Violation(String field, String message) {}
}
